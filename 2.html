<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>Small Map Viewer</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: #e0e0e0; /* 浅灰色背景 */
      overflow: hidden;
    }
    #container {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #frame {
      width: 800px;
      height: 600px;
      background: #c8c8c8; /* 更灰的框 */
      position: relative;
      overflow: hidden;
    }
    #map {
      position: relative;
      transform-origin: 0 0;
      cursor: grab;
      user-select: none;
      line-height: 0;
    }
    #map img {
      display: block;
      user-select: none;
      -webkit-user-drag: none;
    }
    .point {
      position: absolute;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: red;
      transform: translate(-50%, -50%);
      cursor: pointer;
      transition: background-color 0.2s, transform 0.2s;
    }
    .point:hover {
      background: #00ff00;
      transform: translate(-50%, -50%) scale(1.3);
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="frame">
      <div id="map">
        <img src="bndsmap.png" draggable="false" />
      </div>
    </div>
  </div>

  <script>
    const map = document.getElementById('map');
    const mapImg = map.querySelector('img');
    const frame = document.getElementById('frame');

    let scale = 1;
    let translateX = 0;
    let translateY = 0;
    let isDragging = false;
    let startX = 0;
    let startY = 0;

    function updateTransform() {
      map.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
    }

    mapImg.onload = () => {
      // 初始居中
      translateX = (frame.clientWidth - mapImg.naturalWidth) / 2;
      translateY = (frame.clientHeight - mapImg.naturalHeight) / 2;
      updateTransform();
      loadPoints();
    };
    
    if (mapImg.complete) {
      mapImg.onload();
    }

    frame.addEventListener('wheel', (e) => {
      e.preventDefault();
      const rect = frame.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
      const newScale = scale * zoomFactor;

      // 以鼠标位置为中心缩放
      translateX = mouseX - (mouseX - translateX) * (newScale / scale);
      translateY = mouseY - (mouseY - translateY) * (newScale / scale);
      scale = newScale;

      clampPosition();
      updateTransform();
    }, { passive: false });

    frame.addEventListener('mousedown', (e) => {
      isDragging = true;
      startX = e.clientX - translateX;
      startY = e.clientY - translateY;
      map.style.cursor = 'grabbing';
    });

    window.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      translateX = e.clientX - startX;
      translateY = e.clientY - startY;
      clampPosition();
      updateTransform();
    });

    window.addEventListener('mouseup', () => {
      isDragging = false;
      map.style.cursor = 'grab';
    });

    function clampPosition() {
      const mapWidth = mapImg.naturalWidth * scale;
      const mapHeight = mapImg.naturalHeight * scale;

      const minX = frame.clientWidth - mapWidth;
      const minY = frame.clientHeight - mapHeight;

      if (mapWidth <= frame.clientWidth) {
        translateX = (frame.clientWidth - mapWidth) / 2;
      } else {
        translateX = Math.min(0, Math.max(minX, translateX));
      }

      if (mapHeight <= frame.clientHeight) {
        translateY = (frame.clientHeight - mapHeight) / 2;
      } else {
        translateY = Math.min(0, Math.max(minY, translateY));
      }
    }

    async function loadPoints() {
      const response = await fetch('small_map_spot_loc.csv');
      const text = await response.text();
      const lines = text.trim().split('\n');
      
      const hasHeader = lines[0] && lines[0].toLowerCase().includes('spotname');
      const dataLines = hasHeader ? lines.slice(1) : lines;

      dataLines.forEach(line => {
        const parts = line.split(',');
        if (parts.length < 4) return;
        
        const x = parseInt(parts[0].trim(), 10);
        const y = parseInt(parts[1].trim(), 10);
        const name = parts[2].trim();
        const webpFile = parts[3].trim();
        
        if (isNaN(x) || isNaN(y)) return;
        
        const point = document.createElement('div');
        point.className = 'point';
        point.style.left = `${x}px`;
        point.style.top = `${y}px`;
        point.title = name;
        point.addEventListener('click', (e) => {
          e.stopPropagation();
          const mapName = webpFile.replace('.webp', '');
          window.location.href = `index.html?map=${mapName}`;
        });
        map.appendChild(point);
      });
    }
  </script>
</body>
</html>
