<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>全景图查看器</title>
  <style>
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      overflow: hidden;
      background: #0b0c10;
      font-family: "Segoe UI", system-ui, sans-serif;
    }
    #canvas-container {
      position: fixed;
      inset: 0;
      cursor: grab;
    }
    #canvas-container.dragging {
      cursor: grabbing;
    }
    .hint {
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.55);
      color: #e0e6ed;
      padding: 10px 16px;
      border-radius: 12px;
      font-size: 14px;
      letter-spacing: 0.2px;
      backdrop-filter: blur(6px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      user-select: none;
      pointer-events: none;
    }
    .tooltip {
      position: fixed;
      padding: 6px 12px;
      background: rgba(17, 25, 40, 0.78);
      color: #f5f7fa;
      border-radius: 8px;
      font-size: 13px;
      pointer-events: none;
      transform: translate(-50%, calc(-100% - 14px));
      white-space: nowrap;
      border: 1px solid rgba(255, 255, 255, 0.18);
      box-shadow: 0 10px 28px rgba(0, 0, 0, 0.35);
      transition: opacity 0.18s ease;
      opacity: 0;
      z-index: 10;
    }
    .tooltip.show {
      opacity: 1;
    }
    .controls {
      position: fixed;
      right: 16px;
      bottom: 16px;
      display: grid;
      gap: 8px;
      background: rgba(12, 15, 20, 0.78);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      padding: 10px;
      backdrop-filter: blur(8px);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
      z-index: 20;
    }
    .controls button {
      padding: 8px 14px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.04);
      color: #e7e9ed;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.15s ease;
    }
    .controls button:hover {
      border-color: rgba(0, 255, 136, 0.6);
      color: #00ff88;
    }
    .controls button.active {
      background: linear-gradient(135deg, #00b26a, #00ff88);
      border-color: rgba(0, 255, 136, 0.8);
      color: #0c0f14;
      font-weight: 700;
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  <div class="hint">拖拽旋转视角，滚轮缩放。默认载入 output.webp（2:1 全景）。</div>
  <div id="marker-tooltip" class="tooltip"></div>
  <div class="controls">
    <button data-mode="mouse" class="active">鼠标</button>
    <button data-mode="add">添加</button>
    <button data-mode="delete">删除</button>
    <button data-mode="edit">修改</button>
    <button id="save-btn">保存</button>
  </div>
  <script src="./three.min.js"></script>
  <script>
    const container = document.getElementById('canvas-container');
    const tooltip = document.getElementById('marker-tooltip');
    const controlsPanel = document.querySelector('.controls');
    const saveBtn = document.getElementById('save-btn');

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const markerGroup = new THREE.Group();
    const baseMarkerColor = 0xffc857;
    const hoverMarkerColor = 0xffffff;
    const markerGeometry = new THREE.SphereGeometry(4, 16, 16);

    let hoveredMarker = null;
    let panoramaSize = null;
    let csvPoints = [];
    let mode = 'mouse';

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.add(markerGroup);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1100);
    camera.target = new THREE.Vector3(0, 0, 0);

    // 创建朝内的球体网格
    const geometry = new THREE.SphereGeometry(500, 60, 40);
    geometry.scale(-1, 1, 1); // 反转法线以便从内部观察

    const loader = new THREE.TextureLoader();
    const texture = loader.load('lower.webp', (tex) => {
      if (tex.image) {
        panoramaSize = { width: tex.image.width, height: tex.image.height };
        console.log(panoramaSize);
        if (csvPoints.length) {
          buildMarkers();
        }
      }
    }); // 可替换成你的 2:1 全景图路径
    texture.colorSpace = THREE.SRGBColorSpace;

    const material = new THREE.MeshBasicMaterial({ map: texture });
    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    let isUserInteracting = false;
    let onPointerDownMouseX = 0;
    let onPointerDownMouseY = 0;
    let lon = 0;
    let lat = 0;
    let phi = 0;
    let theta = 0;
    let onPointerDownLon = 0;
    let onPointerDownLat = 0;

    loadCsvData();
    setupButtons();

    function onPointerDown(event) {
      if (mode !== 'mouse') {
        handleActionPointer(event);
        return;
      }
      isUserInteracting = true;
      container.classList.add('dragging');
      const { clientX, clientY } = getEventClientPosition(event);
      onPointerDownMouseX = clientX;
      onPointerDownMouseY = clientY;
      onPointerDownLon = lon;
      onPointerDownLat = lat;
      updateMouse(clientX, clientY);
      updateHover();
    }

    function onPointerMove(event) {
      const { clientX, clientY } = getEventClientPosition(event);
      updateMouse(clientX, clientY);
      if (isUserInteracting && mode === 'mouse') {
        lon = (onPointerDownMouseX - clientX) * 0.1 + onPointerDownLon;
        lat = (clientY - onPointerDownMouseY) * 0.1 + onPointerDownLat;
      }
      updateHover();
    }

    function onPointerUp() {
      isUserInteracting = false;
      container.classList.remove('dragging');
    }

    function onWheel(event) {
      event.preventDefault();
      camera.fov = THREE.MathUtils.clamp(camera.fov + event.deltaY * 0.05, 30, 100);
      camera.updateProjectionMatrix();
    }

    container.addEventListener('mousedown', onPointerDown, false);
    container.addEventListener('mousemove', onPointerMove, false);
    container.addEventListener('mouseup', onPointerUp, false);
    container.addEventListener('mouseleave', () => {
      onPointerUp();
      setHoveredMarker(null);
    }, false);

    container.addEventListener('touchstart', onPointerDown, { passive: true });
    container.addEventListener('touchmove', onPointerMove, { passive: true });
    container.addEventListener('touchend', () => {
      onPointerUp();
      setHoveredMarker(null);
    }, { passive: true });

    container.addEventListener('wheel', onWheel, { passive: false });

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onWindowResize, false);

    function animate() {
      requestAnimationFrame(animate);
      update();
      renderer.render(scene, camera);
      postRenderUpdates();
    }

    function update() {
      lat = Math.max(-85, Math.min(85, lat));
      phi = THREE.MathUtils.degToRad(90 - lat);
      theta = THREE.MathUtils.degToRad(lon);

      camera.target.x = 500 * Math.sin(phi) * Math.cos(theta);
      camera.target.y = 500 * Math.cos(phi);
      camera.target.z = 500 * Math.sin(phi) * Math.sin(theta);
      camera.lookAt(camera.target);
    }

    function getEventClientPosition(event) {
      if (event.touches?.length) {
        const touch = event.touches[0];
        return { clientX: touch.clientX, clientY: touch.clientY };
      }
      return { clientX: event.clientX ?? 0, clientY: event.clientY ?? 0 };
    }

    function updateMouse(clientX, clientY) {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
    }

    async function loadCsvData() {
      try {
        const response = await fetch('spot1_trees_loc.csv');
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const text = await response.text();
        csvPoints = text
          .split(/\r?\n/)
          .map((line) => line.trim())
          .filter(Boolean)
          .map((line) => {
            const [xStr, yStr, labelRaw = ''] = line.split(',').map((part) => part.trim());
            return {
              x: Number(xStr),
              y: Number(yStr),
              label: labelRaw || '未知',
            };
          })
          .filter(({ x, y, label }) => Number.isFinite(x) && Number.isFinite(y) && label && !(x === -1 && y === -1));

        if (panoramaSize) {
          buildMarkers();
        }
      } catch (error) {
        console.error('无法读取 pic_trees.csv:', error);
      }
    }

    function buildMarkers() {
      markerGroup.clear();
      csvPoints.forEach(({ x, y, label }) => {
        // 修改说明：
        // 原代码: const lonDeg = (x / panoramaSize.width) * 360 - 180;
        // 现代码: 将角度取反 (加一个负号)，即可实现关于中心(0度)的左右镜像翻转。
        const lonDeg = ((x / panoramaSize.width) * 360);

        const latDeg = 90 - (y / panoramaSize.height) * 180;
        const position = latLonToVector3(latDeg, lonDeg, 490);
        const markerMaterial = new THREE.MeshBasicMaterial({
          color: baseMarkerColor,
          transparent: true,
          opacity: 0.9,
        });
        const marker = new THREE.Mesh(markerGeometry, markerMaterial);
        marker.position.copy(position);
        marker.userData = { label };
        markerGroup.add(marker);
      });
      updateHover();
    }

    function latLonToVector3(latDeg, lonDeg, radius) {
      const phiRad = THREE.MathUtils.degToRad(90 - latDeg);
      const thetaRad = THREE.MathUtils.degToRad(lonDeg);
      const vector = new THREE.Vector3();
      vector.x = radius * Math.sin(phiRad) * Math.cos(thetaRad);
      vector.y = radius * Math.cos(phiRad);
      vector.z = radius * Math.sin(phiRad) * Math.sin(thetaRad);
      return vector;
    }

    function vectorToLatLon(vec) {
      const r = vec.length();
      const phi = Math.acos(vec.y / r);
      const theta = Math.atan2(vec.z, vec.x);
      const latDeg = 90 - THREE.MathUtils.radToDeg(phi);
      let lonDeg = THREE.MathUtils.radToDeg(theta);
      return { latDeg, lonDeg };
    }

    function vectorToImageXY(vec) {
      if (!panoramaSize) return { x: 0, y: 0 };
      const { latDeg, lonDeg } = vectorToLatLon(vec);
      let wrappedLon = lonDeg % 360;
      if (wrappedLon < 0) wrappedLon += 360;
      const x = (wrappedLon / 360) * panoramaSize.width;
      const y = ((90 - latDeg) / 180) * panoramaSize.height;
      return { x, y };
    }

    function updateHover() {
      if (!markerGroup.children.length) {
        setHoveredMarker(null);
        return;
      }
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(markerGroup.children, false);
      setHoveredMarker(intersects.length ? intersects[0].object : null);
    }

    function setHoveredMarker(marker) {
      if (hoveredMarker === marker) {
        if (hoveredMarker) updateTooltipPosition(hoveredMarker);
        return;
      }
      if (hoveredMarker) {
        hoveredMarker.scale.setScalar(1);
        hoveredMarker.material.color.set(baseMarkerColor);
      }
      hoveredMarker = marker;
      if (hoveredMarker) {
        hoveredMarker.scale.setScalar(1.6);
        hoveredMarker.material.color.set(hoverMarkerColor);
        tooltip.textContent = hoveredMarker.userData.label;
        tooltip.classList.add('show');
        updateTooltipPosition(hoveredMarker);
      } else {
        tooltip.classList.remove('show');
      }
    }

    function updateTooltipPosition(marker) {
      const screenPosition = marker.position.clone().project(camera);
      if (screenPosition.z > 1) {
        tooltip.classList.remove('show');
        return;
      }
      const rect = renderer.domElement.getBoundingClientRect();
      const x = (screenPosition.x * 0.5 + 0.5) * rect.width + rect.left;
      const y = (-screenPosition.y * 0.5 + 0.5) * rect.height + rect.top;
      tooltip.style.left = `${x}px`;
      tooltip.style.top = `${y}px`;
    }

    function postRenderUpdates() {
      if (hoveredMarker && tooltip.classList.contains('show')) {
        updateTooltipPosition(hoveredMarker);
      }
    }

    function setupButtons() {
      const buttons = controlsPanel.querySelectorAll('button');
      buttons.forEach((btn) => {
        btn.addEventListener('click', () => {
          buttons.forEach((b) => b.classList.remove('active'));
          btn.classList.add('active');
          mode = btn.dataset.mode;
          container.style.cursor = mode === 'mouse' ? 'grab' : 'crosshair';
          if (mode !== 'mouse') {
            isUserInteracting = false;
            container.classList.remove('dragging');
          }
        });
      });
    }

    function handleActionPointer(event) {
      if (!panoramaSize) return;
      const { clientX, clientY } = getEventClientPosition(event);
      updateMouse(clientX, clientY);
      raycaster.setFromCamera(mouse, camera);

      const markerHits = raycaster.intersectObjects(markerGroup.children, false);

      if (mode === 'delete' && markerHits.length) {
        const hit = markerHits[0].object;
        const idx = markerGroup.children.indexOf(hit);
        if (idx >= 0) {
          const removed = csvPoints.splice(idx, 1);
          buildMarkers();
          console.log(`删除点: ${removed[0]?.label || ''}`);
        }
        return;
      }

      if (mode === 'edit' && markerHits.length) {
        const hit = markerHits[0].object;
        const idx = markerGroup.children.indexOf(hit);
        if (idx >= 0) {
          const current = csvPoints[idx];
          const newName = prompt('输入新的名称', current.label || '');
          if (newName && newName.trim()) {
            csvPoints[idx].label = newName.trim();
            buildMarkers();
            console.log(`修改名称: ${newName.trim()}`);
          }
        }
        return;
      }

      if (mode === 'add') {
        const sphereHits = raycaster.intersectObject(mesh, false);
        if (!sphereHits.length) return;
        const pointOnSphere = sphereHits[0].point.clone().normalize().multiplyScalar(500);
        const { x, y } = vectorToImageXY(pointOnSphere);
        const name = prompt('为新点输入名称');
        if (!name || !name.trim()) return;
        csvPoints.push({ x: Math.round(x), y: Math.round(y), label: name.trim() });
        buildMarkers();
        console.log(`添加点: ${name.trim()} (${Math.round(x)}, ${Math.round(y)})`);
      }
    }

    function downloadCsv() {
      const lines = csvPoints.map(({ x, y, label }) => `${Math.round(x)},${Math.round(y)},${label}`);
      const blob = new Blob([lines.join('\n')], { type: 'text/csv' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'spot1_trees_loc.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(a.href);
    }

    saveBtn.addEventListener('click', () => {
      if (!csvPoints.length) return;
      downloadCsv();
    });

    animate();
  </script>
</body>
</html>
